# 家庭 AI 自动化记账系统 - 完整开发规范

> **文档版本**: v1.0  
> **更新日期**: 2025-12-26  
> **适用对象**: LLM 开发助手 / 人类开发者

---

## 目录

1. [项目概述](#1-项目概述)
2. [环境配置](#2-环境配置)
3. [项目结构](#3-项目结构)
4. [数据库设计](#4-数据库设计)
5. [API 规范](#5-api-规范)
6. [LLM 集成规范](#6-llm-集成规范)
7. [安全规范](#7-安全规范)
8. [交互流程](#8-交互流程)
9. [开发步骤](#9-开发步骤)
10. [测试规范](#10-测试规范)

---

## 1. 项目概述

### 1.1 项目定位

构建一个**多租户 SaaS 型**智能记账 API 服务：
- 用户通过 API 提交"碎碎念"文字或账单截图
- LLM 自动解析为结构化账单数据
- 用户确认后持久化存储
- 支持多渠道接入（HTTP API / Siri Shortcuts / 微信小程序）

### 1.2 核心功能

| 模块 | 功能 |
|------|------|
| 多模态解析器 | 解析文字/图片，提取账单信息 |
| 审计去重器 | 生成 hash_id，检测重复 |
| 用户配置 | 自定义分类/参与人/资产 |
| 确认流程 | 暂存 → 确认 → 入库 |
| 导出功能 | CSV/Excel 导出 |

### 1.3 技术栈

| 组件 | 技术选型 |
|------|---------|
| 后端框架 | Python 3.12+ / FastAPI |
| 数据库 | SQLite 3（开发）/ PostgreSQL（生产） |
| LLM 接口 | OpenRouter API（支持多模型切换） |
| 图像处理 | Pillow + base64 编码 |
| 认证 | JWT Token + API Key |
| 部署 | Docker + Ubuntu 24.04 |

---

## 2. 环境配置

### 2.1 开发环境

```bash
# 系统要求
macOS / Ubuntu 24.04
Python 3.12+

# 创建项目目录
mkdir -p ~/projects/family-accounting
cd ~/projects/family-accounting

# 创建虚拟环境
python3.12 -m venv venv
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt
```

### 2.2 requirements.txt

```txt
# Web 框架
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.0
pydantic-settings==2.1.0

# 数据库
aiosqlite==0.19.0
sqlalchemy==2.0.25

# LLM
httpx==0.26.0

# 图像处理
Pillow==10.2.0

# 认证
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# 工具
python-dotenv==1.0.0
python-multipart==0.0.6

# 测试
pytest==7.4.4
pytest-asyncio==0.23.3
httpx==0.26.0
```

### 2.3 环境变量 (.env)

```bash
# 应用配置
APP_NAME=FamilyAccounting
APP_ENV=development
DEBUG=true
SECRET_KEY=your-secret-key-at-least-32-characters

# 数据库
DATABASE_URL=sqlite+aiosqlite:///./data/accounting.db

# LLM 配置 - OpenRouter
LLM_PROVIDER=openrouter
OPENROUTER_API_KEY=sk-or-v1-xxxxxxxxxxxxxxxx
OPENROUTER_BASE_URL=https://openrouter.ai/api/v1
OPENROUTER_MODEL=openai/gpt-4o
# 备选模型: anthropic/claude-3.5-sonnet, google/gemini-1.5-pro

# 未来自建 LLM（预留）
# LLM_PROVIDER=local
# LOCAL_LLM_URL=http://localhost:8000/v1/chat/completions

# 安全配置
RATE_LIMIT_PER_MINUTE=60
API_KEY_LENGTH=32
JWT_EXPIRE_MINUTES=1440
```

---

## 3. 项目结构

```
family-accounting/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI 应用入口
│   ├── config.py                  # 配置管理
│   │
│   ├── models/
│   │   ├── __init__.py
│   │   ├── database.py            # 数据库连接和 Session
│   │   ├── tables.py              # SQLAlchemy 表定义
│   │   └── schemas.py             # Pydantic 请求/响应模型
│   │
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── auth.py                # 认证相关 API
│   │   ├── record.py              # 记账核心 API
│   │   ├── config.py              # 用户配置 API
│   │   ├── expenses.py            # 账单查询 API
│   │   └── export.py              # 导出 API
│   │
│   ├── services/
│   │   ├── __init__.py
│   │   ├── llm_parser.py          # LLM 解析服务
│   │   ├── auditor.py             # 审计去重服务
│   │   └── user_service.py        # 用户服务
│   │
│   ├── middleware/
│   │   ├── __init__.py
│   │   ├── auth.py                # 认证中间件
│   │   └── rate_limit.py          # 限流中间件
│   │
│   └── utils/
│       ├── __init__.py
│       ├── hash.py                # hash_id 生成
│       └── image.py               # 图片处理
│
├── prompts/
│   └── system_prompt.md           # LLM System Prompt
│
├── scripts/
│   ├── init_db.py                 # 数据库初始化
│   └── create_default_categories.py
│
├── tests/
│   ├── __init__.py
│   ├── conftest.py                # 测试配置
│   ├── test_auth.py
│   ├── test_record.py
│   └── test_llm_parser.py
│
├── data/                          # SQLite 数据库目录
│   └── .gitkeep
│
├── .env.example
├── .gitignore
├── requirements.txt
├── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## 4. 数据库设计

### 4.1 ER 图

```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│   users     │       │ categories  │       │   payees    │
├─────────────┤       ├─────────────┤       ├─────────────┤
│ id (PK)     │───┬───│ user_id(FK) │       │ user_id(FK) │
│ username    │   │   │ main_name   │       │ name        │
│ password    │   │   │ sub_name    │       └─────────────┘
│ api_key     │   │   │ keywords    │
└─────────────┘   │   └─────────────┘       ┌─────────────┐
                  │                         │   assets    │
                  │   ┌─────────────┐       ├─────────────┤
                  │   │  expenses   │       │ user_id(FK) │
                  └───│ user_id(FK) │       │ name        │
                      │ date        │       └─────────────┘
                      │ amount      │
                      │ ...         │       ┌─────────────┐
                      └─────────────┘       │staging_area │
                                            ├─────────────┤
                                            │ user_id(FK) │
                                            │ batch_id    │
                                            │ parsed_json │
                                            │ status      │
                                            └─────────────┘
```

### 4.2 完整 Schema

```sql
-- ============================================
-- 用户表
-- ============================================
CREATE TABLE users (
    id TEXT PRIMARY KEY,                    -- UUID v4
    username TEXT UNIQUE NOT NULL,          -- 用户名（唯一）
    password_hash TEXT NOT NULL,            -- bcrypt 加密密码
    api_key TEXT UNIQUE NOT NULL,           -- 32位 API Key
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_api_key ON users(api_key);

-- ============================================
-- 分类表（用户可自定义）
-- ============================================
CREATE TABLE categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    main_name TEXT NOT NULL,                -- 一级分类
    sub_name TEXT NOT NULL,                 -- 二级分类
    keywords TEXT,                          -- 辅助匹配关键词，逗号分隔
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, main_name, sub_name)
);

CREATE INDEX idx_categories_user ON categories(user_id);

-- ============================================
-- 参与人表（用户可自定义）
-- ============================================
CREATE TABLE payees (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    name TEXT NOT NULL,                     -- 参与人名称
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, name)
);

-- ============================================
-- 资产表（用户可自定义）
-- ============================================
CREATE TABLE assets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    name TEXT NOT NULL,                     -- 资产名称
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, name)
);

-- ============================================
-- 正式账单表
-- ============================================
CREATE TABLE expenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    date TEXT NOT NULL,                     -- 格式：YYYY-MM-DD
    amount REAL NOT NULL,                   -- 金额
    main_category TEXT NOT NULL,            -- 一级分类
    sub_category TEXT,                      -- 二级分类
    payee TEXT,                             -- 参与人
    remark TEXT,                            -- 备注/商户名
    is_essential INTEGER DEFAULT 0,         -- 1:固定支出, 0:变动支出
    linked_asset TEXT,                      -- 关联资产
    hash_id TEXT NOT NULL,                  -- 去重指纹
    source_channel TEXT,                    -- 来源：api/siri/wechat
    original_input TEXT,                    -- 原始输入（便于回溯）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE(user_id, hash_id)
);

CREATE INDEX idx_expenses_user_date ON expenses(user_id, date);
CREATE INDEX idx_expenses_category ON expenses(user_id, main_category);

-- ============================================
-- 审核暂存表
-- ============================================
CREATE TABLE staging_area (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT NOT NULL,
    batch_id TEXT NOT NULL,                 -- 批次ID（UUID）
    temp_id INTEGER NOT NULL,               -- 批次内临时编号（1,2,3...）
    parsed_json TEXT NOT NULL,              -- 解析后的 JSON
    is_duplicate INTEGER DEFAULT 0,         -- 是否重复
    status TEXT DEFAULT 'pending',          -- pending/confirmed/rejected
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_staging_user_batch ON staging_area(user_id, batch_id);
```

### 4.3 默认分类模板

新用户注册时自动初始化以下分类：

```python
DEFAULT_CATEGORIES = [
    # 餐饮
    ("餐饮", "外卖", "美团,饿了么,外卖"),
    ("餐饮", "堂食", "餐厅,饭店"),
    ("餐饮", "食材采购", "买菜,超市,菜市场"),
    ("餐饮", "零食饮料", "零食,饮料,奶茶,咖啡"),
    
    # 交通
    ("交通", "加油", "加油,中石化,中石油"),
    ("交通", "充电", "充电,特斯拉,国家电网"),
    ("交通", "停车", "停车费"),
    ("交通", "公共交通", "地铁,公交,滴滴,出租车"),
    ("交通", "保养维修", "保养,维修,洗车"),
    
    # 购物
    ("购物", "日用品", "日用品,纸巾,洗衣液"),
    ("购物", "服饰", "衣服,鞋子,包"),
    ("购物", "数码电子", "手机,电脑,配件"),
    ("购物", "家居", "家具,家电"),
    
    # 居住
    ("居住", "房租/房贷", "房租,房贷,月供"),
    ("居住", "水电燃气", "水费,电费,燃气费"),
    ("居住", "物业", "物业费"),
    ("居住", "维修装修", "维修,装修"),
    
    # 娱乐
    ("娱乐", "电影", "电影票,影院"),
    ("娱乐", "游戏", "游戏,充值"),
    ("娱乐", "订阅服务", "会员,订阅,Netflix,爱奇艺"),
    ("娱乐", "旅游", "机票,酒店,门票"),
    
    # 医疗健康
    ("医疗健康", "门诊", "挂号,门诊"),
    ("医疗健康", "药品", "药店,药品"),
    ("医疗健康", "体检", "体检"),
    ("医疗健康", "保健", "保健品,健身"),
    
    # 其他
    ("其他", "人情往来", "红包,礼金,礼物"),
    ("其他", "教育", "学费,培训,书籍"),
    ("其他", "保险", "保险费"),
    ("其他", "未分类", ""),
]
```

---

## 5. API 规范

### 5.1 通用规范

**Base URL**: `https://api.example.com/v1`

**认证方式**:
```
Authorization: Bearer <api_key>
```

**请求格式**: `application/json`

**响应格式**:
```json
{
    "success": true,
    "data": { ... },
    "message": "操作成功"
}

// 错误响应
{
    "success": false,
    "error": {
        "code": "INVALID_INPUT",
        "message": "金额格式错误"
    }
}
```

**错误码**:
| 错误码 | HTTP状态 | 说明 |
|--------|---------|------|
| UNAUTHORIZED | 401 | 未认证或 API Key 无效 |
| RATE_LIMITED | 429 | 请求频率超限 |
| INVALID_INPUT | 400 | 输入参数错误 |
| NOT_FOUND | 404 | 资源不存在 |
| DUPLICATE | 409 | 重复记录 |
| SERVER_ERROR | 500 | 服务器内部错误 |

### 5.2 认证 API

#### POST /auth/register
注册新用户

**请求**:
```json
{
    "username": "fujun",
    "password": "your_password"
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "user_id": "uuid-xxxx",
        "username": "fujun",
        "api_key": "fa_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    }
}
```

#### POST /auth/login
用户登录

**请求**:
```json
{
    "username": "fujun",
    "password": "your_password"
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
        "token_type": "bearer",
        "expires_in": 86400
    }
}
```

#### GET /auth/api-key
获取/刷新 API Key（需登录）

**响应**:
```json
{
    "success": true,
    "data": {
        "api_key": "fa_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    }
}
```

### 5.3 记账核心 API

#### POST /record
提交记账内容（文字或图片）

**请求 - 文字**:
```json
{
    "type": "text",
    "content": "今天买菜花了50元，午饭外卖35.5"
}
```

**请求 - 图片**:
```json
{
    "type": "image",
    "content": "base64编码的图片数据",
    "mime_type": "image/jpeg"
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "batch_id": "uuid-batch-xxxx",
        "items": [
            {
                "temp_id": 1,
                "date": "2025-12-26",
                "amount": 50.00,
                "main_category": "餐饮",
                "sub_category": "食材采购",
                "payee": null,
                "remark": "买菜",
                "is_essential": 0,
                "linked_asset": null,
                "is_duplicate": false,
                "confidence": 0.95
            },
            {
                "temp_id": 2,
                "date": "2025-12-26",
                "amount": 35.50,
                "main_category": "餐饮",
                "sub_category": "外卖",
                "payee": null,
                "remark": "午饭外卖",
                "is_essential": 0,
                "linked_asset": null,
                "is_duplicate": false,
                "confidence": 0.92
            }
        ],
        "summary": "共解析 2 条记录，总金额 ¥85.50"
    }
}
```

#### POST /record/confirm
确认入库

**请求 - 全部确认**:
```json
{
    "batch_id": "uuid-batch-xxxx",
    "action": "confirm_all"
}
```

**请求 - 确认指定条目**:
```json
{
    "batch_id": "uuid-batch-xxxx",
    "action": "confirm",
    "temp_ids": [1, 2]
}
```

**请求 - 修改后确认**:
```json
{
    "batch_id": "uuid-batch-xxxx",
    "action": "modify",
    "temp_id": 1,
    "modifications": {
        "main_category": "购物",
        "sub_category": "日用品"
    }
}
```

**响应**:
```json
{
    "success": true,
    "data": {
        "confirmed_count": 2,
        "skipped_duplicates": 0
    }
}
```

#### POST /record/reject
拒绝/取消

**请求**:
```json
{
    "batch_id": "uuid-batch-xxxx",
    "action": "reject_all"
}
```

### 5.4 用户配置 API

#### GET /config/categories
获取用户分类列表

**响应**:
```json
{
    "success": true,
    "data": [
        {
            "id": 1,
            "main_name": "餐饮",
            "sub_name": "外卖",
            "keywords": "美团,饿了么"
        }
    ]
}
```

#### POST /config/categories
添加新分类

**请求**:
```json
{
    "main_name": "宠物",
    "sub_name": "猫粮",
    "keywords": "猫粮,猫砂"
}
```

#### DELETE /config/categories/{id}
删除分类

#### 同理：/config/payees 和 /config/assets

### 5.5 账单查询 API

#### GET /expenses
查询账单列表

**查询参数**:
| 参数 | 类型 | 说明 |
|------|------|------|
| start_date | string | 开始日期 YYYY-MM-DD |
| end_date | string | 结束日期 YYYY-MM-DD |
| main_category | string | 一级分类筛选 |
| payee | string | 参与人筛选 |
| page | int | 页码，默认 1 |
| page_size | int | 每页数量，默认 20，最大 100 |

**响应**:
```json
{
    "success": true,
    "data": {
        "items": [...],
        "pagination": {
            "page": 1,
            "page_size": 20,
            "total": 156,
            "total_pages": 8
        },
        "summary": {
            "total_amount": 12580.50,
            "category_breakdown": {
                "餐饮": 3500.00,
                "交通": 1200.00
            }
        }
    }
}
```

### 5.6 导出 API

#### GET /export/csv
导出 CSV

**查询参数**: 同 `/expenses`

**响应**: 直接返回 CSV 文件
```
Content-Type: text/csv
Content-Disposition: attachment; filename="expenses_2025-12.csv"
```

---

## 6. LLM 集成规范

### 6.1 OpenRouter 调用

```python
# app/services/llm_parser.py

import httpx
from app.config import settings

class LLMParser:
    def __init__(self):
        self.client = httpx.AsyncClient(
            base_url=settings.OPENROUTER_BASE_URL,
            headers={
                "Authorization": f"Bearer {settings.OPENROUTER_API_KEY}",
                "HTTP-Referer": "https://your-app.com",
                "X-Title": "Family Accounting"
            },
            timeout=30.0
        )
    
    async def parse(self, content: str, user_categories: list) -> list:
        """解析文字/图片内容"""
        system_prompt = self._build_system_prompt(user_categories)
        
        response = await self.client.post(
            "/chat/completions",
            json={
                "model": settings.OPENROUTER_MODEL,
                "messages": [
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": content}
                ],
                "response_format": {"type": "json_object"},
                "temperature": 0.1  # 低温度保证稳定性
            }
        )
        
        result = response.json()
        return self._parse_response(result)
```

### 6.2 System Prompt 模板

```markdown
# prompts/system_prompt.md

你是一个智能记账助手，负责将用户的自然语言描述或账单截图解析为结构化的账单数据。

## 输出格式

必须返回严格的 JSON 格式：
```json
{
    "items": [
        {
            "date": "YYYY-MM-DD",
            "amount": 50.00,
            "main_category": "餐饮",
            "sub_category": "食材采购",
            "payee": null,
            "remark": "买菜",
            "is_essential": 0,
            "linked_asset": null
        }
    ]
}
```

## 用户的分类体系

{categories_json}

## 用户的参与人列表

{payees_json}

## 用户的资产列表

{assets_json}

## 解析规则

1. **日期推断**：
   - 明确日期直接使用
   - "今天"/"昨天" 根据当前日期推算
   - 无日期信息默认今天

2. **金额处理**：
   - 移除货币符号（¥、$）
   - 处理千分位逗号
   - 保留两位小数

3. **分类匹配**：
   - 优先匹配用户自定义分类
   - 使用 keywords 辅助匹配
   - 无法确定时使用 "其他/未分类"

4. **参与人推断**：
   - 根据上下文推断
   - 无法确定时为 null

5. **资产关联**：
   - 识别与特定资产相关的支出
   - 如 "特斯拉充电" → linked_asset: "Tesla"

## 重要提示

- 单次输入可能包含多条账单，需全部解析
- 图片可能是账单截图，需识别所有消费条目
- 对于模糊信息，选择最可能的分类，而非留空
```

### 6.3 多模态处理

```python
async def parse_image(self, image_base64: str, mime_type: str, user_categories: list) -> list:
    """解析图片内容"""
    system_prompt = self._build_system_prompt(user_categories)
    
    response = await self.client.post(
        "/chat/completions",
        json={
            "model": settings.OPENROUTER_MODEL,  # 需支持 vision
            "messages": [
                {"role": "system", "content": system_prompt},
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:{mime_type};base64,{image_base64}"
                            }
                        },
                        {
                            "type": "text",
                            "text": "请解析这张账单/消费截图中的所有消费记录"
                        }
                    ]
                }
            ],
            "response_format": {"type": "json_object"}
        }
    )
    
    return self._parse_response(response.json())
```

### 6.4 降级策略

```python
async def parse_with_fallback(self, content: str, user_categories: list) -> list:
    """带降级的解析"""
    try:
        return await self.parse(content, user_categories)
    except httpx.TimeoutException:
        # 超时：返回待人工分类
        return self._create_manual_item(content)
    except Exception as e:
        logger.error(f"LLM 解析失败: {e}")
        return self._create_manual_item(content)

def _create_manual_item(self, content: str) -> list:
    """创建待人工分类的条目"""
    return [{
        "date": datetime.now().strftime("%Y-%m-%d"),
        "amount": 0,
        "main_category": "其他",
        "sub_category": "未分类",
        "remark": f"[待人工处理] {content[:100]}",
        "confidence": 0
    }]
```

---

## 7. 安全规范

### 7.1 认证机制

```python
# app/middleware/auth.py

from fastapi import Security, HTTPException
from fastapi.security import APIKeyHeader

api_key_header = APIKeyHeader(name="Authorization", auto_error=False)

async def verify_api_key(api_key: str = Security(api_key_header)):
    """验证 API Key"""
    if not api_key or not api_key.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing API Key")
    
    token = api_key.replace("Bearer ", "")
    
    # 查询数据库验证
    user = await get_user_by_api_key(token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid API Key")
    
    return user
```

### 7.2 限流实现

```python
# app/middleware/rate_limit.py

from collections import defaultdict
import time

class RateLimiter:
    def __init__(self, max_requests: int = 60, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window = window_seconds
        self.requests = defaultdict(list)
    
    def is_allowed(self, user_id: str) -> bool:
        """检查用户是否可以发起请求"""
        now = time.time()
        window_start = now - self.window
        
        # 清理过期记录
        self.requests[user_id] = [
            t for t in self.requests[user_id] if t > window_start
        ]
        
        if len(self.requests[user_id]) >= self.max_requests:
            return False
        
        self.requests[user_id].append(now)
        return True

# 使用
rate_limiter = RateLimiter(max_requests=60, window_seconds=60)

@app.middleware("http")
async def rate_limit_middleware(request: Request, call_next):
    user = request.state.user  # 从认证中间件获取
    if user and not rate_limiter.is_allowed(user.id):
        return JSONResponse(
            status_code=429,
            content={"error": {"code": "RATE_LIMITED", "message": "请求过于频繁，请稍后再试"}}
        )
    return await call_next(request)
```

### 7.3 输入验证

```python
# app/models/schemas.py

from pydantic import BaseModel, Field, field_validator
from decimal import Decimal

class RecordRequest(BaseModel):
    type: Literal["text", "image"]
    content: str = Field(..., min_length=1, max_length=10000)
    mime_type: Optional[str] = None
    
    @field_validator("content")
    def validate_content(cls, v, info):
        if info.data.get("type") == "image":
            # 验证 base64 格式
            try:
                base64.b64decode(v)
            except:
                raise ValueError("无效的图片数据")
            # 限制图片大小 (约 5MB base64)
            if len(v) > 7_000_000:
                raise ValueError("图片过大，请压缩后重试")
        return v

class ExpenseItem(BaseModel):
    amount: Decimal = Field(..., ge=0.01, le=1_000_000)
    date: str = Field(..., pattern=r"^\d{4}-\d{2}-\d{2}$")
    main_category: str = Field(..., min_length=1, max_length=50)
    
    @field_validator("date")
    def validate_date(cls, v):
        try:
            date_obj = datetime.strptime(v, "%Y-%m-%d")
            # 不能是未来日期
            if date_obj.date() > datetime.now().date():
                raise ValueError("日期不能是未来")
            # 不能超过一年前
            if date_obj.date() < (datetime.now() - timedelta(days=365)).date():
                raise ValueError("日期不能超过一年前")
        except ValueError as e:
            raise ValueError(f"日期格式错误: {e}")
        return v
```

### 7.4 数据隔离

```python
# 所有数据库查询必须带 user_id 条件

async def get_expenses(user_id: str, filters: dict) -> list:
    """获取用户账单（强制隔离）"""
    query = select(Expense).where(Expense.user_id == user_id)
    
    if filters.get("start_date"):
        query = query.where(Expense.date >= filters["start_date"])
    if filters.get("end_date"):
        query = query.where(Expense.date <= filters["end_date"])
    
    return await db.execute(query)
```

### 7.5 日志脱敏

```python
# app/utils/logging.py

import re

def sanitize_log(data: dict) -> dict:
    """脱敏敏感信息"""
    sensitive_fields = ["password", "api_key", "amount", "remark"]
    sanitized = data.copy()
    
    for field in sensitive_fields:
        if field in sanitized:
            if field == "amount":
                sanitized[field] = "***"
            elif field == "remark":
                sanitized[field] = sanitized[field][:10] + "..."
            else:
                sanitized[field] = "******"
    
    return sanitized
```

---

## 8. 交互流程

### 8.1 记账完整流程

```
用户                API                LLM              数据库
 │                   │                  │                 │
 │──POST /record────>│                  │                 │
 │                   │──解析请求───────>│                 │
 │                   │<─返回 JSON───────│                 │
 │                   │                                    │
 │                   │──查询用户分类──────────────────────>│
 │                   │<─返回分类列表──────────────────────│
 │                   │                                    │
 │                   │──计算 hash_id 检测重复─────────────>│
 │                   │<─返回重复状态──────────────────────│
 │                   │                                    │
 │                   │──写入 staging_area─────────────────>│
 │                   │                                    │
 │<─返回解析结果─────│                                    │
 │                   │                                    │
 │──POST /confirm───>│                                    │
 │                   │──移动至 expenses──────────────────>│
 │                   │──删除 staging───────────────────>│
 │<─确认成功─────────│                                    │
```

### 8.2 确认指令规范

| 指令 | 含义 | 示例 |
|------|------|------|
| 全部确认 | 确认所有非重复条目 | `{"action": "confirm_all"}` |
| 部分确认 | 确认指定编号 | `{"action": "confirm", "temp_ids": [1,3]}` |
| 修改后确认 | 修改某条后确认 | `{"action": "modify", "temp_id": 2, "modifications": {...}}` |
| 全部拒绝 | 放弃本批次 | `{"action": "reject_all"}` |

### 8.3 hash_id 计算

```python
# app/utils/hash.py

import hashlib

def generate_hash_id(user_id: str, date: str, amount: float, remark: str, payee: str = None) -> str:
    """
    生成去重指纹
    包含 user_id 确保用户间隔离
    """
    raw = f"{user_id}|{date}|{amount:.2f}|{remark or ''}|{payee or ''}"
```

### 8.4 ⭐ 核心设计：LLM 智能分类与多轮确认（重中之重）

> [!IMPORTANT]
> **这是本项目的核心卖点**：LLM 自动分类 + 支持多条目来回反复确认修改。
> 用户可能一次提交多条账单，需要逐条确认、修改、增加分类，整个过程需要流畅自然。

#### 8.4.1 多条目交互流程状态机

```
                    ┌──────────────────────────────────────────────────┐
                    │                                                  │
                    ▼                                                  │
    ┌─────────┐   解析   ┌─────────┐   用户操作   ┌─────────┐         │
    │  输入   │ ───────▶ │ 暂存区  │ ───────────▶ │ 确认中  │ ────────┤
    └─────────┘         └─────────┘              └─────────┘         │
                              │                       │               │
                              │ 超时清理              │ 有剩余条目    │
                              ▼                       ▼               │
                        ┌─────────┐             ┌─────────┐           │
                        │ 已过期  │             │ 部分确认│ ──────────┘
                        └─────────┘             └─────────┘
                                                      │
                                                      │ 全部处理完
                                                      ▼
                                                ┌─────────┐
                                                │ 完成入库│
                                                └─────────┘
```

#### 8.4.2 多轮交互示例（完整对话流程）

```
═══════════════════════════════════════════════════════════════════
第 1 轮：用户提交
═══════════════════════════════════════════════════════════════════

用户: "今天买菜50，午饭外卖35，给车充电200"

系统返回:
{
    "batch_id": "batch-001",
    "items": [
        {"temp_id": 1, "amount": 50, "category": "餐饮/食材采购", "remark": "买菜", "confidence": 0.95},
        {"temp_id": 2, "amount": 35, "category": "餐饮/外卖", "remark": "午饭外卖", "confidence": 0.92},
        {"temp_id": 3, "amount": 200, "category": "交通/充电", "remark": "给车充电", "confidence": 0.88}
    ],
    "prompt": "请确认以上 3 条记录，或输入序号进行修改"
}

═══════════════════════════════════════════════════════════════════
第 2 轮：用户部分确认 + 修改
═══════════════════════════════════════════════════════════════════

用户: "1和2确认，3改成特斯拉充电"

系统处理:
- 条目 1, 2 → 确认入库
- 条目 3 → 更新备注，保持待确认

系统返回:
{
    "batch_id": "batch-001",
    "confirmed": [1, 2],
    "remaining": [
        {"temp_id": 3, "amount": 200, "category": "交通/充电", "remark": "特斯拉充电", "linked_asset": "Tesla"}
    ],
    "prompt": "已确认 2 条，还有 1 条待确认"
}

═══════════════════════════════════════════════════════════════════
第 3 轮：用户继续修改或确认
═══════════════════════════════════════════════════════════════════

用户: "3分类改成'汽车/充电'"  (用户想用自定义分类)

系统检测: 用户分类库中不存在 "汽车/充电"

系统返回:
{
    "action_required": "create_category",
    "message": "分类 '汽车/充电' 不存在，是否创建？",
    "options": ["是，创建并使用", "否，使用 交通/充电"]
}

═══════════════════════════════════════════════════════════════════
第 4 轮：用户确认创建新分类
═══════════════════════════════════════════════════════════════════

用户: "是，创建"

系统处理:
- 创建新分类 "汽车/充电"
- 更新条目 3 的分类
- 自动确认入库

系统返回:
{
    "batch_id": "batch-001",
    "status": "completed",
    "summary": "已创建新分类 '汽车/充电'，全部 3 条记录已入库",
    "total_amount": 285.00
}
```

#### 8.4.3 用户操作指令规范

| 指令类型 | 示例输入 | 系统解析 |
|---------|---------|---------|
| **全部确认** | `"确认"` / `"Y"` / `"全部确认"` | 确认所有非重复条目 |
| **部分确认** | `"1和2确认"` / `"确认1,2"` | 只确认指定编号 |
| **修改分类** | `"3分类改成购物"` / `"3:购物/日用品"` | 修改指定条目的分类 |
| **修改金额** | `"2金额改成40"` | 修改金额 |
| **修改备注** | `"1备注改成菜市场买菜"` | 修改备注 |
| **修改参与人** | `"3参与人改成付清辰"` | 修改参与人 |
| **删除条目** | `"删除2"` / `"2不要了"` | 删除指定条目 |
| **追加条目** | `"再加一条：停车费20"` | 追加到当前批次 |
| **全部取消** | `"取消"` / `"不记了"` | 放弃整个批次 |

#### 8.4.4 LLM 指令解析设计

```python
# app/services/instruction_parser.py

class InstructionParser:
    """
    解析用户的确认/修改指令
    这是多轮交互的核心
    """
    
    async def parse_instruction(self, user_input: str, batch_context: dict) -> dict:
        """
        使用 LLM 解析用户的自然语言指令
        
        返回结构:
        {
            "action": "confirm" | "modify" | "delete" | "add" | "cancel" | "create_category",
            "targets": [1, 2, 3],  # 目标条目编号
            "modifications": {     # 修改内容
                "main_category": "购物",
                "sub_category": "日用品",
                "amount": 50.00,
                "remark": "xxx"
            },
            "new_category": {      # 创建新分类（如需要）
                "main_name": "汽车",
                "sub_name": "充电"
            }
        }
        """
        
        system_prompt = f"""
你是一个指令解析助手，负责理解用户对记账条目的操作指令。

当前批次包含以下条目：
{json.dumps(batch_context['items'], ensure_ascii=False, indent=2)}

用户的分类列表：
{json.dumps(batch_context['categories'], ensure_ascii=False)}

请解析用户的指令，返回 JSON 格式的操作指令。

注意事项：
1. 用户可能同时对多个条目进行操作
2. 用户可能使用口语化的表达，需要理解其真实意图
3. 如果用户提到不存在的分类，标记 action 为 "create_category"
4. 对于模糊表达，优先选择最可能的解释
"""
        
        response = await self.llm_client.parse(user_input, system_prompt)
        return self._validate_instruction(response, batch_context)
```

#### 8.4.5 批次状态管理

```python
# app/services/batch_manager.py

class BatchManager:
    """
    管理多轮确认过程中的批次状态
    """
    
    async def get_batch_status(self, user_id: str, batch_id: str) -> dict:
        """获取批次当前状态"""
        items = await self.db.get_staging_items(user_id, batch_id)
        
        return {
            "batch_id": batch_id,
            "total_count": len(items),
            "pending_count": len([i for i in items if i.status == "pending"]),
            "confirmed_count": len([i for i in items if i.status == "confirmed"]),
            "rejected_count": len([i for i in items if i.status == "rejected"]),
            "items": items,
            "is_complete": all(i.status != "pending" for i in items)
        }
    
    async def apply_instruction(self, user_id: str, batch_id: str, instruction: dict) -> dict:
        """
        应用用户指令到批次
        
        返回：更新后的批次状态 + 需要用户响应的内容
        """
        action = instruction["action"]
        
        if action == "confirm":
            return await self._confirm_items(user_id, batch_id, instruction["targets"])
        
        elif action == "modify":
            return await self._modify_items(user_id, batch_id, instruction)
        
        elif action == "delete":
            return await self._delete_items(user_id, batch_id, instruction["targets"])
        
        elif action == "add":
            return await self._add_items(user_id, batch_id, instruction["new_items"])
        
        elif action == "create_category":
            return await self._prompt_create_category(user_id, instruction["new_category"])
        
        elif action == "cancel":
            return await self._cancel_batch(user_id, batch_id)
    
    async def _confirm_items(self, user_id: str, batch_id: str, targets: list) -> dict:
        """确认指定条目入库"""
        confirmed = []
        skipped_duplicates = []
        
        for temp_id in targets:
            item = await self.db.get_staging_item(user_id, batch_id, temp_id)
            
            if item.is_duplicate:
                skipped_duplicates.append(temp_id)
                continue
            
            # 写入正式表
            await self.db.insert_expense(user_id, item.to_expense())
            # 更新暂存状态
            await self.db.update_staging_status(user_id, batch_id, temp_id, "confirmed")
            confirmed.append(temp_id)
        
        return {
            "confirmed": confirmed,
            "skipped_duplicates": skipped_duplicates,
            "remaining": await self._get_pending_items(user_id, batch_id)
        }
```

#### 8.4.6 暂存区超时清理

```python
# 暂存区自动清理机制
# 超过 30 分钟未确认的批次自动过期

async def cleanup_expired_staging():
    """定时任务：清理过期暂存"""
    expire_threshold = datetime.now() - timedelta(minutes=30)
    
    await db.execute("""
        UPDATE staging_area 
        SET status = 'expired' 
        WHERE status = 'pending' 
        AND created_at < ?
    """, [expire_threshold])
```

#### 8.4.7 分类自学习机制

```python
# app/services/category_learner.py

class CategoryLearner:
    """
    LLM 分类结果的自学习优化
    """
    
    async def learn_from_correction(self, user_id: str, original: dict, corrected: dict):
        """
        从用户纠正中学习
        
        当用户将 "买菜" 从 "购物/日用品" 改为 "餐饮/食材采购" 时，
        系统记录这个模式，下次自动使用正确分类
        """
        
        # 1. 更新分类关键词
        await self._add_keyword_to_category(
            user_id=user_id,
            main_name=corrected["main_category"],
            sub_name=corrected["sub_category"],
            keyword=original["remark"]  # 将备注作为关键词
        )
        
        # 2. 记录纠正历史（用于分析）
        await self._log_correction(user_id, original, corrected)
    
    async def suggest_category(self, user_id: str, remark: str) -> dict:
        """
        基于历史记录和关键词匹配，提供分类建议
        """
        # 1. 精确关键词匹配
        exact_match = await self._find_by_keyword(user_id, remark)
        if exact_match:
            return {"category": exact_match, "confidence": 0.99, "source": "keyword"}
        
        # 2. 历史相似记录匹配
        similar = await self._find_similar_expense(user_id, remark)
        if similar:
            return {"category": similar.category, "confidence": 0.85, "source": "history"}
        
        # 3. 默认使用 LLM 推断
        return None
```

#### 8.4.8 API 端点：多轮交互

```python
# app/routers/record.py

@router.post("/record/interact")
async def interact_with_batch(
    request: InteractionRequest,
    user: User = Depends(verify_api_key)
):
    """
    多轮交互端点
    
    用户可以反复调用此接口，直到批次全部完成
    """
    batch_manager = BatchManager(db)
    instruction_parser = InstructionParser(llm_client)
    
    # 1. 解析用户指令
    instruction = await instruction_parser.parse_instruction(
        user_input=request.instruction,
        batch_context=await batch_manager.get_batch_status(user.id, request.batch_id)
    )
    
    # 2. 应用指令
    result = await batch_manager.apply_instruction(
        user_id=user.id,
        batch_id=request.batch_id,
        instruction=instruction
    )
    
    # 3. 检查是否需要用户进一步操作
    if result.get("action_required"):
        return {
            "success": True,
            "data": result,
            "requires_response": True
        }
    
    # 4. 检查是否全部完成
    status = await batch_manager.get_batch_status(user.id, request.batch_id)
    if status["is_complete"]:
        return {
            "success": True,
            "data": {
                "status": "completed",
                "summary": f"全部 {status['confirmed_count']} 条记录已入库"
            }
        }
    
    # 5. 还有待处理条目
    return {
        "success": True,
        "data": {
            "status": "in_progress",
            "remaining": status["items"],
            "prompt": f"还有 {status['pending_count']} 条待确认"
        }
    }
```

#### 8.4.9 交互请求/响应模型

```python
# app/models/schemas.py

class InteractionRequest(BaseModel):
    """多轮交互请求"""
    batch_id: str
    instruction: str  # 用户的自然语言指令
    
class InteractionResponse(BaseModel):
    """多轮交互响应"""
    success: bool
    data: InteractionData
    requires_response: bool = False  # 是否需要用户进一步回应

class InteractionData(BaseModel):
    status: Literal["in_progress", "completed", "action_required"]
    confirmed: Optional[List[int]] = None
    remaining: Optional[List[StagingItem]] = None
    action_required: Optional[str] = None  # 如 "create_category"
    message: Optional[str] = None
    prompt: Optional[str] = None
    summary: Optional[str] = None
```

---


## 9. 开发步骤

### 第一阶段：基础设施（预计 3 天）

#### 步骤 1.1：项目初始化
```bash
mkdir family-accounting && cd family-accounting
python -m venv venv && source venv/bin/activate
pip install fastapi uvicorn pydantic python-dotenv
```

#### 步骤 1.2：配置模块
创建 `app/config.py`，实现：
- 环境变量加载
- OpenRouter 配置
- 数据库 URL 配置

#### 步骤 1.3：数据库模块
创建 `app/models/database.py` 和 `app/models/tables.py`：
- SQLAlchemy 异步连接
- 所有表定义
- 初始化脚本

#### 步骤 1.4：认证模块
创建 `app/routers/auth.py`：
- 用户注册（自动生成 API Key）
- 用户登录（返回 JWT）
- 密码加密（bcrypt）

#### 步骤 1.5：中间件
- API Key 验证中间件
- 限流中间件

---

### 第二阶段：核心功能（预计 4 天）

#### 步骤 2.1：LLM 解析器
创建 `app/services/llm_parser.py`：
- OpenRouter API 调用封装
- System Prompt 动态构建
- 文字/图片解析
- 降级策略

#### 步骤 2.2：用户配置 API
创建 `app/routers/config.py`：
- 分类 CRUD
- 参与人 CRUD
- 资产 CRUD
- 新用户自动初始化默认分类

#### 步骤 2.3：审计去重器
创建 `app/services/auditor.py`：
- hash_id 生成
- 重复检测
- 置信度评估

#### 步骤 2.4：记账核心 API
创建 `app/routers/record.py`：
- POST /record（解析入口）
- POST /record/confirm（确认入库）
- POST /record/reject（拒绝）

---

### 第三阶段：查询与导出（预计 2 天）

#### 步骤 3.1：账单查询
创建 `app/routers/expenses.py`：
- 列表查询（分页、筛选）
- 统计汇总

#### 步骤 3.2：导出功能
创建 `app/routers/export.py`：
- CSV 导出
- 中文 Excel 格式

---

### 第四阶段：文档与测试（预计 1 天）

#### 步骤 4.1：API 文档
- 配置 FastAPI 自动文档
- 编写 README

#### 步骤 4.2：测试
- 单元测试
- API 集成测试

---

## 10. 测试规范

### 10.1 测试文件结构

```
tests/
├── conftest.py          # 测试配置和 fixtures
├── test_auth.py         # 认证测试
├── test_record.py       # 记账 API 测试
├── test_llm_parser.py   # LLM 解析测试
└── test_auditor.py      # 去重测试
```

### 10.2 测试用例示例

```python
# tests/test_record.py

import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_record_text(client: AsyncClient, auth_headers: dict):
    """测试文字记账"""
    response = await client.post(
        "/record",
        headers=auth_headers,
        json={
            "type": "text",
            "content": "今天买菜花了50元"
        }
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["success"] == True
    assert len(data["data"]["items"]) == 1
    assert data["data"]["items"][0]["amount"] == 50.0
    assert data["data"]["items"][0]["main_category"] == "餐饮"

@pytest.mark.asyncio
async def test_duplicate_detection(client: AsyncClient, auth_headers: dict):
    """测试重复检测"""
    # 第一次记录
    await client.post("/record", headers=auth_headers, json={"type": "text", "content": "买菜50元"})
    await client.post("/record/confirm", headers=auth_headers, json={"action": "confirm_all"})
    
    # 第二次相同记录
    response = await client.post(
        "/record",
        headers=auth_headers,
        json={"type": "text", "content": "买菜50元"}
    )
    
    assert response.json()["data"]["items"][0]["is_duplicate"] == True
```

### 10.3 运行测试

```bash
# 运行所有测试
pytest tests/ -v

# 运行特定测试
pytest tests/test_record.py -v

# 生成覆盖率报告
pytest tests/ --cov=app --cov-report=html
```

---

## 附录 A：Siri Shortcuts 对接指南

### ⚠️ Siri 多轮交互限制

> [!WARNING]
> **Siri Shortcuts 原生不支持多轮对话**，只能一问一答。

#### 解决方案对比

| 方案 | 实现方式 | 优点 | 缺点 |
|------|---------|------|------|
| **A：高置信自动入库** | 置信度 > 0.9 自动入库，< 0.9 暂存 | 最简单 | 低置信需其他渠道确认 |
| **B：语音播报确认** | Siri 解析后播报，用户说"确认" | 接近多轮 | 实现复杂 |
| **C：推送通知确认** | 解析后推送通知，点击确认 | 用户体验好 | 需要 App |
| **D：跳转小程序确认** | Siri 返回链接，跳转确认 | 完整流程 | 多一步操作 |

#### 推荐方案：高置信自动入库 + 暂存

```
用户: "嘿 Siri，记一笔，买菜50元"
        ↓
API 解析后判断置信度:
  - confidence >= 0.9 → 直接入库，语音回复"已记录"
  - confidence < 0.9  → 暂存，语音回复"已暂存，请稍后确认"
                        （用户可通过微信/Web 确认）
```

#### Siri 专用 API 端点

```python
@router.post("/siri/record")
async def siri_record(request: SiriRecordRequest, user: User = Depends(verify_api_key)):
    """
    Siri 专用端点：高置信自动入库
    """
    # 解析
    items = await llm_parser.parse(request.content, user.categories)
    
    auto_confirmed = []
    pending = []
    
    for item in items:
        if item.confidence >= 0.9 and not item.is_duplicate:
            # 高置信：直接入库
            await db.insert_expense(user.id, item)
            auto_confirmed.append(item)
        else:
            # 低置信/重复：暂存
            await db.insert_staging(user.id, item)
            pending.append(item)
    
    # 返回语音播报文本
    if pending:
        return {"speech": f"已记录 {len(auto_confirmed)} 条，{len(pending)} 条待确认"}
    else:
        total = sum(i.amount for i in auto_confirmed)
        return {"speech": f"已记录 {len(auto_confirmed)} 条，共 {total} 元"}
```

### 创建快捷指令（文字版）

1. 打开 iOS 快捷指令 App
2. 创建新快捷指令，添加操作：
   - **听写文本**
   - **获取 URL 内容**
     - URL: `https://api.example.com/v1/siri/record`
     - 方法: POST
     - 请求体: JSON
     ```json
     {
         "type": "text",
         "content": "[听写结果]"
     }
     ```
     - 请求头: `Authorization: Bearer [你的API Key]`
   - **朗读文本**：朗读返回的 speech 字段

3. 设置触发词："记一笔"

### 创建快捷指令（图片版）

1. 创建新快捷指令，添加操作：
   - **选择照片**（可多选）
   - **将图像转换为 Base64**
   - **获取 URL 内容**
     - URL: `https://api.example.com/v1/siri/record`
     - 方法: POST
     - 请求体: JSON
     ```json
     {
         "type": "image",
         "content": "[Base64图片数据]",
         "mime_type": "image/jpeg"
     }
     ```
   - **朗读文本**

2. 设置触发词："拍账单"

---

## 附录 B：图片传输完整方案

### 传输方式对比

| 方式 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **Base64 in JSON** | Siri、小程序、简单场景 | 实现简单 | 体积增大 33% |
| **multipart/form-data** | Web、复杂 App | 标准方式 | Siri 不支持 |
| **先上传再引用** | 多图、大图 | 灵活 | 多一步 |

### 方式 1：Base64 in JSON（推荐）

**请求示例**：
```json
{
    "type": "image",
    "content": "/9j/4AAQSkZJRgABAQEASABIAAD/2wBDA...",
    "mime_type": "image/jpeg"
}
```

**Siri Shortcuts 实现**：
```
选择照片 → 转换为 JPEG → Base64 编码 → 放入 JSON → 发送
```

**服务端处理**：
```python
@router.post("/record")
async def record(request: RecordRequest):
    if request.type == "image":
        # 解码 Base64
        image_bytes = base64.b64decode(request.content)
        
        # 验证大小（限制 5MB）
        if len(image_bytes) > 5 * 1024 * 1024:
            raise HTTPException(400, "图片过大")
        
        # 调用多模态 LLM
        items = await llm_parser.parse_image(
            image_base64=request.content,
            mime_type=request.mime_type,
            user_categories=user.categories
        )
```

### 方式 2：multipart/form-data

**请求示例**：
```bash
curl -X POST https://api.example.com/v1/record \
  -H "Authorization: Bearer <api_key>" \
  -F "type=image" \
  -F "image=@/path/to/bill.jpg"
```

**服务端处理**：
```python
from fastapi import File, UploadFile

@router.post("/record/upload")
async def record_upload(
    type: str = Form(...),
    image: UploadFile = File(None),
    text: str = Form(None),
    user: User = Depends(verify_api_key)
):
    if type == "image" and image:
        content = await image.read()
        image_base64 = base64.b64encode(content).decode()
        items = await llm_parser.parse_image(image_base64, image.content_type)
```

### 方式 3：先上传再引用（大图场景）

**步骤 1：上传图片**
```json
POST /upload
{
    "image": "<base64>"
}

Response:
{
    "image_id": "img_xxxx",
    "expires_at": "2025-12-26T14:00:00Z"
}
```

**步骤 2：引用图片记账**
```json
POST /record
{
    "type": "image_ref",
    "image_id": "img_xxxx"
}
```

### 各渠道图片传输方式

| 渠道 | 推荐方式 | 说明 |
|------|---------|------|
| **Siri Shortcuts** | Base64 in JSON | 快捷指令可选择照片并转 Base64 |
| **微信小程序** | Base64 in JSON | wx.chooseImage + wx.getFileSystemManager |
| **Web 前端** | multipart/form-data | 标准文件上传 |
| **API 直接调用** | 任意 | 根据场景选择 |

---

## 附录 C：微信小程序对接指南

### 后端 CORS 配置

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://servicewechat.com"],
    allow_methods=["POST", "GET"],
    allow_headers=["Authorization", "Content-Type"],
)
```

### 小程序端调用

```javascript
// 记账
wx.request({
    url: 'https://api.example.com/v1/record',
    method: 'POST',
    header: {
        'Authorization': 'Bearer ' + app.globalData.apiKey,
        'Content-Type': 'application/json'
    },
    data: {
        type: 'text',
        content: this.data.inputText
    },
    success: (res) => {
        // 显示解析结果供用户确认
    }
});
```

---

## 附录 D：Web 前端规范（PC + 移动端自适应）

### 技术选型

| 组件 | 技术 | 说明 |
|------|------|------|
| 框架 | 原生 HTML/CSS/JS 或 Vue 3 | 轻量优先 |
| UI 库 | 无（自定义 CSS）| 避免依赖 |
| 响应式 | CSS Flexbox + Media Queries | PC/手机自适应 |
| 语音 | Web Speech API | 浏览器原生支持 |
| 图片 | File API + Canvas | 压缩后上传 |

### 页面结构

```
Web 前端/
├── index.html          # 主页面
├── css/
│   └── style.css       # 响应式样式
├── js/
│   ├── api.js          # API 调用封装
│   ├── voice.js        # 语音录入
│   ├── image.js        # 图片处理
│   └── main.js         # 主逻辑
└── assets/
    └── icons/          # 图标
```

### 核心功能界面

```
┌──────────────────────────────────────────┐
│  🏠 家庭记账                    [登录/用户名] │
├──────────────────────────────────────────┤
│                                          │
│  ┌────────────────────────────────────┐  │
│  │                                    │  │
│  │     [📷]    [🎤]    [⌨️]          │  │
│  │     图片    语音    文字           │  │
│  │                                    │  │
│  └────────────────────────────────────┘  │
│                                          │
│  ┌────────────────────────────────────┐  │
│  │  输入区域                          │  │
│  │  ________________________________  │  │
│  │  |                              |  │  │
│  │  |  今天买菜50，午饭35...        |  │  │
│  │  |______________________________|  │  │
│  │                                    │  │
│  │              [🚀 提交]             │  │
│  └────────────────────────────────────┘  │
│                                          │
│  ──────── 待确认 (2条) ────────         │
│                                          │
│  ┌────────────────────────────────────┐  │
│  │ 1. 餐饮/食材采购  ¥50.00           │  │
│  │    买菜  [✓确认] [✏修改] [✗删除]  │  │
│  ├────────────────────────────────────┤  │
│  │ 2. 餐饮/外卖     ¥35.00            │  │
│  │    午饭  [✓确认] [✏修改] [✗删除]  │  │
│  └────────────────────────────────────┘  │
│                                          │
│           [✓ 全部确认]                   │
│                                          │
└──────────────────────────────────────────┘
```

### 响应式 CSS 设计

```css
/* css/style.css */

:root {
    --primary-color: #4CAF50;
    --danger-color: #f44336;
    --bg-color: #f5f5f5;
    --card-bg: #ffffff;
    --text-color: #333333;
    --border-radius: 12px;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: var(--bg-color);
    color: var(--text-color);
    min-height: 100vh;
}

.container {
    max-width: 600px;
    margin: 0 auto;
    padding: 16px;
}

/* 输入模式切换按钮 */
.input-mode-tabs {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin: 24px 0;
}

.mode-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 16px 24px;
    border: none;
    background: var(--card-bg);
    border-radius: var(--border-radius);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.mode-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
}

.mode-btn.active {
    background: var(--primary-color);
    color: white;
}

.mode-btn .icon {
    font-size: 32px;
    margin-bottom: 8px;
}

/* 输入区域 */
.input-area {
    background: var(--card-bg);
    border-radius: var(--border-radius);
    padding: 16px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.text-input {
    width: 100%;
    min-height: 100px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    font-size: 16px;
    resize: vertical;
}

/* 语音录制按钮 */
.voice-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: none;
    background: var(--primary-color);
    color: white;
    font-size: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 24px auto;
    cursor: pointer;
    transition: all 0.2s;
}

.voice-btn.recording {
    background: var(--danger-color);
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* 图片上传区域 */
.image-upload {
    border: 2px dashed #ccc;
    border-radius: var(--border-radius);
    padding: 32px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s;
}

.image-upload:hover {
    border-color: var(--primary-color);
}

.image-upload.drag-over {
    border-color: var(--primary-color);
    background: rgba(76, 175, 80, 0.1);
}

.image-preview {
    max-width: 100%;
    max-height: 200px;
    margin-top: 16px;
    border-radius: 8px;
}

/* 待确认列表 */
.pending-list {
    margin-top: 24px;
}

.pending-item {
    background: var(--card-bg);
    border-radius: var(--border-radius);
    padding: 16px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.pending-item .category {
    color: var(--primary-color);
    font-weight: 600;
}

.pending-item .amount {
    font-size: 20px;
    font-weight: bold;
    float: right;
}

.pending-item .actions {
    margin-top: 12px;
    display: flex;
    gap: 8px;
}

.pending-item .actions button {
    flex: 1;
    padding: 8px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.btn-confirm {
    background: var(--primary-color);
    color: white;
}

.btn-edit {
    background: #2196F3;
    color: white;
}

.btn-delete {
    background: var(--danger-color);
    color: white;
}

/* 提交按钮 */
.submit-btn {
    width: 100%;
    padding: 16px;
    border: none;
    border-radius: var(--border-radius);
    background: var(--primary-color);
    color: white;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    margin-top: 16px;
}

.submit-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
}

/* 响应式：手机端 */
@media (max-width: 768px) {
    .container {
        padding: 12px;
    }
    
    .input-mode-tabs {
        gap: 16px;
    }
    
    .mode-btn {
        padding: 12px 16px;
    }
    
    .mode-btn .icon {
        font-size: 24px;
    }
}
```

### 语音录入实现

```javascript
// js/voice.js

class VoiceRecorder {
    constructor() {
        this.recognition = null;
        this.isRecording = false;
        this.onResult = null;
        this.onError = null;
        
        this.init();
    }
    
    init() {
        // 检查浏览器支持
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        
        if (!SpeechRecognition) {
            console.error('浏览器不支持语音识别');
            return;
        }
        
        this.recognition = new SpeechRecognition();
        this.recognition.lang = 'zh-CN';
        this.recognition.continuous = true;
        this.recognition.interimResults = true;
        
        this.recognition.onresult = (event) => {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                transcript += event.results[i][0].transcript;
            }
            if (this.onResult) {
                this.onResult(transcript, event.results[event.results.length - 1].isFinal);
            }
        };
        
        this.recognition.onerror = (event) => {
            console.error('语音识别错误:', event.error);
            if (this.onError) {
                this.onError(event.error);
            }
        };
        
        this.recognition.onend = () => {
            this.isRecording = false;
        };
    }
    
    start() {
        if (!this.recognition) {
            alert('您的浏览器不支持语音识别，请使用 Chrome 或 Safari');
            return false;
        }
        
        try {
            this.recognition.start();
            this.isRecording = true;
            return true;
        } catch (e) {
            console.error('启动语音识别失败:', e);
            return false;
        }
    }
    
    stop() {
        if (this.recognition && this.isRecording) {
            this.recognition.stop();
            this.isRecording = false;
        }
    }
}

// 使用示例
const voiceRecorder = new VoiceRecorder();

document.getElementById('voiceBtn').addEventListener('click', function() {
    if (voiceRecorder.isRecording) {
        voiceRecorder.stop();
        this.classList.remove('recording');
        this.textContent = '🎤';
    } else {
        voiceRecorder.onResult = (text, isFinal) => {
            document.getElementById('textInput').value = text;
        };
        
        if (voiceRecorder.start()) {
            this.classList.add('recording');
            this.textContent = '⏹️';
        }
    }
});
```

### 图片处理实现

```javascript
// js/image.js

class ImageProcessor {
    constructor(maxWidth = 1280, quality = 0.8) {
        this.maxWidth = maxWidth;
        this.quality = quality;
    }
    
    /**
     * 压缩并转换为 Base64
     */
    async processFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // 等比缩放
                    if (width > this.maxWidth) {
                        height = (this.maxWidth / width) * height;
                        width = this.maxWidth;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // 转换为 Base64
                    const base64 = canvas.toDataURL('image/jpeg', this.quality);
                    const base64Data = base64.split(',')[1];
                    
                    resolve({
                        base64: base64Data,
                        mimeType: 'image/jpeg',
                        width: width,
                        height: height,
                        originalSize: file.size,
                        compressedSize: Math.round(base64Data.length * 0.75) // 估算
                    });
                };
                
                img.onerror = reject;
                img.src = e.target.result;
            };
            
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }
}

// 使用示例
const imageProcessor = new ImageProcessor();

document.getElementById('imageUpload').addEventListener('change', async function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        const result = await imageProcessor.processFile(file);
        
        // 显示预览
        document.getElementById('imagePreview').src = `data:image/jpeg;base64,${result.base64}`;
        document.getElementById('imagePreview').style.display = 'block';
        
        // 保存到全局变量供提交使用
        window.pendingImage = result;
        
        console.log(`图片压缩: ${result.originalSize} -> ${result.compressedSize} bytes`);
    } catch (err) {
        console.error('图片处理失败:', err);
        alert('图片处理失败，请重试');
    }
});

// 拖拽上传
const dropZone = document.getElementById('imageUpload');

dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('drag-over');
});

dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('drag-over');
});

dropZone.addEventListener('drop', async (e) => {
    e.preventDefault();
    dropZone.classList.remove('drag-over');
    
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
        // 同上处理逻辑
    }
});
```

### API 调用封装

```javascript
// js/api.js

class AccountingAPI {
    constructor(baseUrl) {
        this.baseUrl = baseUrl;
        this.apiKey = localStorage.getItem('api_key') || '';
    }
    
    setApiKey(key) {
        this.apiKey = key;
        localStorage.setItem('api_key', key);
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
            ...options.headers
        };
        
        const response = await fetch(url, {
            ...options,
            headers
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || '请求失败');
        }
        
        return response.json();
    }
    
    // 登录
    async login(username, password) {
        const result = await this.request('/auth/login', {
            method: 'POST',
            body: JSON.stringify({ username, password })
        });
        this.setApiKey(result.data.api_key);
        return result;
    }
    
    // 提交记账（文字）
    async recordText(content) {
        return this.request('/record', {
            method: 'POST',
            body: JSON.stringify({ type: 'text', content })
        });
    }
    
    // 提交记账（图片）
    async recordImage(base64, mimeType) {
        return this.request('/record', {
            method: 'POST',
            body: JSON.stringify({ 
                type: 'image', 
                content: base64,
                mime_type: mimeType
            })
        });
    }
    
    // 多轮交互
    async interact(batchId, instruction) {
        return this.request('/record/interact', {
            method: 'POST',
            body: JSON.stringify({ batch_id: batchId, instruction })
        });
    }
    
    // 确认全部
    async confirmAll(batchId) {
        return this.request('/record/confirm', {
            method: 'POST',
            body: JSON.stringify({ batch_id: batchId, action: 'confirm_all' })
        });
    }
    
    // 获取账单列表
    async getExpenses(params = {}) {
        const query = new URLSearchParams(params).toString();
        return this.request(`/expenses?${query}`);
    }
}

// 初始化
const api = new AccountingAPI('https://api.example.com/v1');
```

### 主逻辑

```javascript
// js/main.js

let currentBatchId = null;
let pendingItems = [];

// 切换输入模式
document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        const mode = this.dataset.mode;
        document.querySelectorAll('.input-panel').forEach(p => p.style.display = 'none');
        document.getElementById(`${mode}Panel`).style.display = 'block';
    });
});

// 提交处理
document.getElementById('submitBtn').addEventListener('click', async function() {
    const mode = document.querySelector('.mode-btn.active').dataset.mode;
    let result;
    
    this.disabled = true;
    this.textContent = '处理中...';
    
    try {
        if (mode === 'text') {
            const text = document.getElementById('textInput').value.trim();
            if (!text) {
                alert('请输入内容');
                return;
            }
            result = await api.recordText(text);
            
        } else if (mode === 'image') {
            if (!window.pendingImage) {
                alert('请先选择图片');
                return;
            }
            result = await api.recordImage(
                window.pendingImage.base64,
                window.pendingImage.mimeType
            );
            
        } else if (mode === 'voice') {
            const text = document.getElementById('textInput').value.trim();
            if (!text) {
                alert('请先录音');
                return;
            }
            result = await api.recordText(text);
        }
        
        // 显示待确认列表
        currentBatchId = result.data.batch_id;
        pendingItems = result.data.items;
        renderPendingItems();
        
    } catch (err) {
        alert('提交失败: ' + err.message);
    } finally {
        this.disabled = false;
        this.textContent = '🚀 提交';
    }
});

// 渲染待确认列表
function renderPendingItems() {
    const container = document.getElementById('pendingList');
    
    if (pendingItems.length === 0) {
        container.innerHTML = '<p>暂无待确认记录</p>';
        return;
    }
    
    container.innerHTML = pendingItems.map(item => `
        <div class="pending-item" data-id="${item.temp_id}">
            <span class="category">${item.main_category}/${item.sub_category}</span>
            <span class="amount">¥${item.amount.toFixed(2)}</span>
            <div class="remark">${item.remark || ''}</div>
            <div class="actions">
                <button class="btn-confirm" onclick="confirmItem(${item.temp_id})">✓确认</button>
                <button class="btn-edit" onclick="editItem(${item.temp_id})">✏修改</button>
                <button class="btn-delete" onclick="deleteItem(${item.temp_id})">✗删除</button>
            </div>
        </div>
    `).join('');
    
    // 显示全部确认按钮
    document.getElementById('confirmAllBtn').style.display = 'block';
}

// 确认单条
async function confirmItem(tempId) {
    try {
        await api.interact(currentBatchId, `确认${tempId}`);
        pendingItems = pendingItems.filter(i => i.temp_id !== tempId);
        renderPendingItems();
        
        if (pendingItems.length === 0) {
            alert('全部确认完成！');
        }
    } catch (err) {
        alert('确认失败: ' + err.message);
    }
}

// 修改
function editItem(tempId) {
    const item = pendingItems.find(i => i.temp_id === tempId);
    const newCategory = prompt('请输入新分类（格式：一级分类/二级分类）', 
        `${item.main_category}/${item.sub_category}`);
    
    if (newCategory) {
        api.interact(currentBatchId, `${tempId}分类改成${newCategory}`)
            .then(() => {
                const [main, sub] = newCategory.split('/');
                item.main_category = main;
                item.sub_category = sub || '';
                renderPendingItems();
            })
            .catch(err => alert('修改失败: ' + err.message));
    }
}

// 删除
async function deleteItem(tempId) {
    if (!confirm('确定删除这条记录？')) return;
    
    try {
        await api.interact(currentBatchId, `删除${tempId}`);
        pendingItems = pendingItems.filter(i => i.temp_id !== tempId);
        renderPendingItems();
    } catch (err) {
        alert('删除失败: ' + err.message);
    }
}

// 全部确认
document.getElementById('confirmAllBtn').addEventListener('click', async function() {
    try {
        await api.confirmAll(currentBatchId);
        pendingItems = [];
        renderPendingItems();
        document.getElementById('confirmAllBtn').style.display = 'none';
        alert('全部确认完成！');
    } catch (err) {
        alert('确认失败: ' + err.message);
    }
});
```

### HTML 主页面

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>家庭记账</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>🏠 家庭记账</h1>
        </header>
        
        <!-- 输入模式切换 -->
        <div class="input-mode-tabs">
            <button class="mode-btn active" data-mode="text">
                <span class="icon">⌨️</span>
                <span>文字</span>
            </button>
            <button class="mode-btn" data-mode="voice">
                <span class="icon">🎤</span>
                <span>语音</span>
            </button>
            <button class="mode-btn" data-mode="image">
                <span class="icon">📷</span>
                <span>图片</span>
            </button>
        </div>
        
        <!-- 文字输入面板 -->
        <div id="textPanel" class="input-panel input-area">
            <textarea id="textInput" class="text-input" 
                placeholder="输入消费记录，如：今天买菜50，午饭35..."></textarea>
            <button id="submitBtn" class="submit-btn">🚀 提交</button>
        </div>
        
        <!-- 语音输入面板 -->
        <div id="voicePanel" class="input-panel input-area" style="display:none;">
            <button id="voiceBtn" class="voice-btn">🎤</button>
            <p style="text-align:center;color:#666;">点击开始录音</p>
            <textarea id="voiceText" class="text-input" 
                placeholder="语音识别结果将显示在这里..." readonly></textarea>
            <button id="submitBtn2" class="submit-btn">🚀 提交</button>
        </div>
        
        <!-- 图片上传面板 -->
        <div id="imagePanel" class="input-panel input-area" style="display:none;">
            <label class="image-upload">
                <input type="file" id="imageInput" accept="image/*" style="display:none;">
                <span>📷 点击或拖拽上传账单图片</span>
                <img id="imagePreview" class="image-preview" style="display:none;">
            </label>
            <button id="submitBtn3" class="submit-btn">🚀 提交</button>
        </div>
        
        <!-- 待确认列表 -->
        <div class="pending-list">
            <h3>待确认记录</h3>
            <div id="pendingList"></div>
            <button id="confirmAllBtn" class="submit-btn" style="display:none;">
                ✓ 全部确认
            </button>
        </div>
    </div>
    
    <script src="js/api.js"></script>
    <script src="js/voice.js"></script>
    <script src="js/image.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
```

### 移动端适配要点

1. **viewport meta**：必须设置 `width=device-width, initial-scale=1.0`
2. **触摸友好**：按钮最小 44x44px，间距足够
3. **语音权限**：首次使用需要用户授权麦克风
4. **图片选择**：移动端可直接调用相机 `capture="environment"`
5. **键盘适配**：输入框聚焦时避免被键盘遮挡

### 浏览器兼容性

| 功能 | Chrome | Safari | Firefox | 微信内置 |
|------|--------|--------|---------|---------|
| 语音识别 | ✅ | ✅ | ❌ | ✅ |
| 图片压缩 | ✅ | ✅ | ✅ | ✅ |
| 文件拖拽 | ✅ | ✅ | ✅ | ❌ |

---

**文档结束**
